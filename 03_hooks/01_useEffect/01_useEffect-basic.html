<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id = "root"></div>

    <!-- 
        Hooks는 리엑트 16.8에서 도입된 기능으로, 함수형 컴포넌트에서 사용 불가능한
        생명주기 메소드의 한계점으로 인해 상태관리 및 렌더링 이후 시점 컨트롤 등, 
        다양한 문제를 해결하기 위해 나온 함수 집합을 의미한다.

        컴포넌트가 렌더링 된 이후에 특정 작업을 수행할 필요가 있다면 클래스형 컴포넌트에서는
        componentDidMount 혹은 componentDidUpdate 메소드를 이용하면 된다.
        하지만 함수형 컴포넌트에는 생명주기 API를 사용할 수 없기 때문에 Hooks을 제공하고 있고
        렌더링 이후 작업을 수행할 수 있게 해주는 useEffect가 있다.
    -->
    <script type = "text/babel">

        // useEffect 구조분해 할당으로 바로 사용
        const {useEffect} = React;
        
        function MessagePrinter({message}){

            // const {message} = props;

            console.log(message);
                    
            console.log('렌더링...');

            // 화면이 동작한 이후에 그려지는 hooks-useEffect
            useEffect(() => {
                console.log('렌더링 이후 동작...');
                console.log(message);
                
                
            })
            
            // 중괄호는 자바 스크립트 코드 칠 수 있음.
            return(
                <h1>{console.log('렌더링시 출력...')}{message}</h1>
            )

            // 이 위치에서 (마운트 or 업데이트 이후에) 무언가 동작하게 하고 싶지만 동작하지 않는다.
            // 리턴 뒤에 있는 코드는 작동하지 않는 의미없는 코드다.
            // 이 시점에서 실행하고 싶은 것을 useEffect를 이용해서 처리할 수 있다.
            // console.log('렌더링 이후 동작...');
            
        }
        
        const message = '안녕하세요';

        ReactDOM.createRoot(document.getElementById('root')).render(<MessagePrinter message = {message}/>);
    </script>
</body>
</html>